{"ts":1341021617755,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* @pjs font=\"ARLRDBD.TTF\"; */\n\nvar width = 600;\nvar height = 600;\n\n/*\npositions\n0---------1\n|         |\n|         |\n|         |\n3---------2\n*/\nvar positions = [{x:0,y:0},{x:width,y:0},{x:width,y:height},{x:0,y:height}];\nvar diam = 40;\nvar namePositions = [{x:25+diam,y:25},{x:width-25-diam,y:25},{x:width-25-diam,y:height-25},{x:25+diam,y:height-25}];\n\n//counter\nvar counter = 0;\n\nPFont myFont;\n\nvoid setup(){\n    size(width,height);\n    smooth();\n    myFont = createFont(\"ARLRDBD.TTF\", 13);\n}\n\nvoid draw(){\n    if(bg == 'black'){\n        background(0);\n    } else {\n        background(255);\n    }\n    //draw frame\n    stroke(0);\n    line(0,0,width,0);\n    line(0,0,0,height);\n    line(width-1,0,width-1,height);\n    line(0,height-1,width,height-1);\n    noStroke();\n    //get updates from server\n    update();\n    \n    var reset = true;\n    //draw the table\n    for(var i in table){\n        var col = table[i].color;\n        reset = reset && (col == '#ffffff');\n        if(bg == 'white' && col == '#ffffff'){\n            col = '#000000'\n        }\n        var r = parseInt(col.substring(1,3),16);\n        var g = parseInt(col.substring(3,5),16);\n        var b = parseInt(col.substring(5,7),16);\n        fill(r,g,b);\n        ellipse(positions[i].x,positions[i].y, diam, diam);\n        var x = namePositions[i].x;\n        if(i == 1 || i == 2){\n            x -= (table[i].name.length) * 3; \n        }\n        text(table[i].name,x, namePositions[i].y);\n    }\n    \n    if(reset){\n        //if reset is still true the server may have been reset\n        resetClient();\n    } else {\n        //we have atleast one user logged in, it is possible to reset\n        resetable = true;\n    }\n    \n    if(type != 'none'){\n        //draw old circles\n        for(var i in circles){\n            if(type == 'circles' && circles[i].l != 4){\n                continue;\n            }\n            fill(circles[i].r,circles[i].g,circles[i].b,circles[i].a);\n            ellipse(circles[i].x,circles[i].y,2*circles[i].rad,2*circles[i].rad);\n        }\n        //draw new sentiments\n        while(sentimentBuffer.length != 0){\n            var sentiment = sentimentBuffer.pop();\n            //we draw one circle or splatter for each keyword\n            //since all the colors in sentiment.color are adjusted for\n            //the sentiment, we can pick any one of them\n            int r = parseInt(sentiment.color.substring(1,3),16);\n            int g = parseInt(sentiment.color.substring(3,5),16);\n            int b = parseInt(sentiment.color.substring(5,7),16);\n            var i = parseInt(sentiment.index)%30;\n            int x = (7*i*Math.cos(i)) + (width/2);\n            int y = (7*i*Math.sin(i)) + (height/2);\n            if (type == 'splatters'){\n                drawCircles(x,y,15,4, r, g, b);\n            } else {\n                drawCircles(x,y,15,1, r, g, b);\n            }\n        }\n    }\n}\n\nvoid mouseClicked(){\n    var x = mouseX;\n    var y = mouseY;\n    if(pos >= 0 && pos <=3){\n        //user has already signed in\n        return;\n    }\n    for(var i in positions){\n        if(table[i].color != '#ffffff'){\n            //some other user is logged in at this position\n            continue;\n        }\n        if(x >= (positions[i].x - diam/2) && x <= (positions[i].x + diam/2) &&\n           y >= (positions[i].y - diam/2) && y <= (positions[i].y + diam/2) ){\n            pos = i;\n            $('#adduser').show();\n            return;\n        }\n    }\n    //the user clicked on something other than one of the circles\n    pos = -1;\n    $('#username').val('');\n    $('#color').val('');\n    $('#adduser').hide();\n}\n\n// Circle splatter machine\nvoid drawCircles(float x, float y, int radius, int level, float r, float g, float b)\n{\n  noStroke();\n  //save this circle\n  circles.push({\n    x : x,\n    y : y,\n    rad : radius,\n    r : r,\n    g : g,\n    b : b,\n    a : 170,\n    l : level\n  });\n  fill(r,g,b,170);\n  ellipse(x, y, radius*2, radius*2);\n  if (level > 1) {\n    level = level - 1;\n    int num = int (random(2, 5));\n    for(int i=0; i<num; i++) {\n      float a = random(0, TWO_PI);\n      float nx = x + cos(a) * 6.0 * level;\n      float ny = y + sin(a) * 6.0 * level;\n      drawCircles(nx, ny, radius/2, level, r, g, b);\n    }\n  }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":4217}]],"length":4217}
{"contributors":[],"silentsave":false,"ts":1343869564599,"patch":[[{"diffs":[[0,"(x,y,15,"],[-1,"4"],[1,"sentiment.amp"],[0,", r, g, "]],"start1":2751,"start2":2751,"length1":17,"length2":29}]],"length":4229,"saved":false}
